import sys
import argparse
import random
import time
import requests
import socket
from io import BytesIO
from urllib.parse import urlparse

# #############################################################################
# Optional: Pyfiglet for fancy ASCII banner
# #############################################################################
try:
    from pyfiglet import Figlet
    PYFIGLET_INSTALLED = True
except ImportError:
    PYFIGLET_INSTALLED = False

# #############################################################################
# ANSI Color Codes (for console output)
# #############################################################################
CYAN = "\033[36m"
YELLOW = "\033[33m"
RESET = "\033[0m"

def print_banner():
    """Displays the same fancy ASCII banner from the scanner."""
    if PYFIGLET_INSTALLED:
        f = Figlet(font="slant")
        banner_text = f.renderText("Hikvision Exploit")
        print(f"{CYAN}{banner_text}{RESET}")
    else:
        # If pyfiglet isn't installed, just print a simple banner
        print("Hikvision Exploit")

    print("=" * 80)
    print(f"{CYAN}  Hikvision Exploitation Toolkit - Red Team Edition {RESET}")
    print(f"{CYAN}  Made by #AfterDark {RESET}")
    print("=" * 80)
    print(f"{YELLOW}[!] DISCLAIMER: This tool is for authorized testing only. {RESET}")
    print(f"{YELLOW}    The author assumes no liability for misuse. {RESET}")
    print("=" * 80)

# #############################################################################
# PySide6 / Qt Imports
# #############################################################################
from PySide6.QtCore import (
    Qt, QTimer, QThread, Signal
)
from PySide6.QtGui import (
    QPixmap, QImage, QColor, QCursor, QPainter
)
from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QLabel, QVBoxLayout, QHBoxLayout,
    QGridLayout, QScrollArea, QFrame, QGraphicsDropShadowEffect, QSizePolicy,
    QGraphicsScene, QGraphicsView, QGraphicsPixmapItem
)

# #############################################################################
# Material Dark Constants
# #############################################################################
PRIMARY_BG    = "#121212"
ACCENT_COLOR  = "#BB86FC"
TEXT_COLOR    = "#FFFFFF"
CARD_BG       = "#1C1C1C"
SECONDARY_TEXT= "#B0B0B0"

# #############################################################################
# Tor Utilities
# #############################################################################
def get_tor_session():
    """Create a requests session routed through Tor."""
    session = requests.Session()
    session.proxies = {
        "http": "socks5h://127.0.0.1:9050",
        "https": "socks5h://127.0.0.1:9050",
    }
    return session

def check_tor_running():
    """
    Check if Tor is running by attempting a request via socks5h proxy.
    Return True if Tor is reachable, False otherwise.
    """
    try:
        session = get_tor_session()
        resp = session.get("http://httpbin.org/ip", timeout=5)
        if resp.status_code == 200:
            ip = resp.json().get("origin", "Unknown")
            print(f"[INFO] Tor is running. Current Tor Exit Node IP: {ip}")
            return True
        else:
            print(f"[ERROR] Tor check failed with status code {resp.status_code}.")
            return False
    except Exception as e:
        print(f"[ERROR] Tor is not running or unreachable: {e}")
        return False

# #############################################################################
# CameraFeedWorker
# #############################################################################
class CameraFeedWorker(QThread):
    """
    Continuously fetches snapshots from a camera URL and emits QImage frames.
    """
    image_updated = Signal(QImage)
    error_signal = Signal(str)

    def __init__(self, url, refresh_interval=1.0, use_tor=False):
        super().__init__()
        self.url = url
        self.refresh_interval = refresh_interval
        self.use_tor = use_tor
        self._running = True
        self.session = get_tor_session() if use_tor else requests.Session()

    def run(self):
        while self._running:
            try:
                response = self.session.get(self.url, timeout=10)
                if response.status_code == 200:
                    data = BytesIO(response.content)
                    qimage = QImage.fromData(data.getvalue())
                    if not qimage.isNull():
                        self.image_updated.emit(qimage)
            except Exception as e:
                self.error_signal.emit(f"Failed to fetch {self.url}: {e}")

            time.sleep(self.refresh_interval)

    def stop(self):
        """Politely ask the thread to exit, then wait."""
        self._running = False
        self.quit()
        self.wait()

# #############################################################################
# ZoomableGraphicsView
# #############################################################################
class ZoomableGraphicsView(QGraphicsView):
    """
    A QGraphicsView that supports wheel-based zooming and panning.
    This is used to display a static snapshot, not a live feed.
    """
    def __init__(self, scene, parent=None):
        super().__init__(scene, parent)

        # Use QPainter's enum to enable antialiasing
        self.setRenderHints(self.renderHints() | QPainter.Antialiasing)

        self.setDragMode(self.DragMode.ScrollHandDrag)  # allow panning
        self.scale_factor = 1.0

    def wheelEvent(self, event):
        """
        Zoom in/out with the mouse wheel, preserving center.
        """
        zoom_in_factor = 1.25
        zoom_out_factor = 1 / zoom_in_factor

        if event.angleDelta().y() > 0:
            zoom_factor = zoom_in_factor
        else:
            zoom_factor = zoom_out_factor

        old_center = self.mapToScene(self.viewport().rect().center())

        self.scale(zoom_factor, zoom_factor)
        self.scale_factor *= zoom_factor

        new_center = self.mapToScene(self.viewport().rect().center())
        translation = new_center - old_center
        self.translate(translation.x(), translation.y())

# #############################################################################
# SnapshotWindow
# #############################################################################
class SnapshotWindow(QMainWindow):
    """
    A window that displays a single snapshot (still image).
    You can zoom/pan using ZoomableGraphicsView. This is not live.
    """
    def __init__(self, pixmap):
        super().__init__()
        self.setWindowTitle("Snapshot Analysis")

        # Scene + view for panning/zooming
        self.scene = QGraphicsScene(self)
        self.view = ZoomableGraphicsView(self.scene, self)
        self.view.setScene(self.scene)

        # QGraphicsPixmapItem to hold the snapshot
        self.pixmap_item = QGraphicsPixmapItem()
        self.pixmap_item.setPixmap(pixmap)
        self.scene.addItem(self.pixmap_item)

        # Layout
        central_widget = QWidget()
        layout = QVBoxLayout(central_widget)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(self.view)
        self.setCentralWidget(central_widget)

        # Set an initial window size
        screen = QApplication.primaryScreen().availableGeometry()
        w = int(screen.width() * 0.4)
        h = int(screen.height() * 0.4)
        self.setGeometry(100, 100, w, h)

# #############################################################################
# TrafficCanvas
# #############################################################################
import matplotlib
matplotlib.use('QtAgg')
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg

class TrafficCanvas(FigureCanvasQTAgg):
    def __init__(self, parent=None, title="Traffic Monitor"):
        fig, self.ax = plt.subplots(figsize=(4, 2))
        super().__init__(fig)
        self.setParent(parent)
        fig.patch.set_facecolor(PRIMARY_BG)
        self.ax.set_facecolor(PRIMARY_BG)
        self.ax.tick_params(colors=TEXT_COLOR, labelsize=8)
        self.ax.xaxis.label.set_color(TEXT_COLOR)
        self.ax.yaxis.label.set_color(TEXT_COLOR)
        self.ax.title.set_color(ACCENT_COLOR)
        self.ax.set_title(title)

        self.data = [0]*50
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_plot)
        self.timer.start(1000)

    def update_plot(self):
        self.data.append(random.randint(1, 100))
        self.data = self.data[-50:]
        self.ax.clear()
        self.ax.set_facecolor(PRIMARY_BG)
        self.ax.plot(self.data, color=ACCENT_COLOR, label="Traffic (KB/s)")
        self.ax.set_ylabel("Traffic (KB/s)", color=TEXT_COLOR)
        self.ax.set_xlabel("Time (s)", color=TEXT_COLOR)
        self.ax.legend(facecolor=PRIMARY_BG, edgecolor=PRIMARY_BG, labelcolor=TEXT_COLOR)
        self.draw()

# #############################################################################
# TrafficMonitorWindow
# #############################################################################
class TrafficMonitorWindow(QMainWindow):
    def __init__(self, use_tor=False):
        super().__init__()
        self.use_tor = use_tor
        self.setWindowTitle("Network Traffic Monitor (Material Dark)")

        main_widget = QWidget()
        main_layout = QVBoxLayout(main_widget)
        self.setCentralWidget(main_widget)

        self.ip_label = QLabel("Fetching IP...", self)
        self.ip_label.setObjectName("ipLabel")
        main_layout.addWidget(self.ip_label, alignment=Qt.AlignHCenter)

        self.canvas = TrafficCanvas(parent=self, title="Tor Traffic" if self.use_tor else "Network Traffic")
        main_layout.addWidget(self.canvas)

        self.apply_style()

        # Timer for IP updates
        self.ip_timer = QTimer()
        self.ip_timer.timeout.connect(self.update_ip)
        self.ip_timer.start(5000)

        # Position + size
        screen = QApplication.primaryScreen().availableGeometry()
        width = int(screen.width() * 0.25)
        height = int(screen.height() * 0.3)
        x = int(screen.width() * 0.7) + 70
        y = 50
        self.setGeometry(x, y, width, height)

    def apply_style(self):
        self.setStyleSheet(f"""
            QMainWindow {{
                background-color: {PRIMARY_BG};
            }}
            QWidget {{
                background-color: {PRIMARY_BG};
                color: {TEXT_COLOR};
                font-family: Roboto, Arial, sans-serif;
            }}
            QLabel#ipLabel {{
                font-size: 14px;
                font-weight: bold;
                color: {ACCENT_COLOR};
                padding: 10px;
            }}
        """)

    def update_ip(self):
        try:
            session = get_tor_session() if self.use_tor else requests.Session()
            resp = session.get("http://httpbin.org/ip", timeout=5)
            if resp.status_code == 200:
                ip = resp.json().get("origin", "Unknown")
                if self.use_tor:
                    self.ip_label.setText(f"Tor Exit Node: {ip}")
                else:
                    self.ip_label.setText(f"Current IP: {ip}")
            else:
                self.ip_label.setText("Error fetching IP")
        except Exception as e:
            self.ip_label.setText("Error fetching IP")
            print("[ERROR]", e)

# #############################################################################
# SnapshotFeedLabel => opens a SnapshotWindow with the last known image
# #############################################################################
class SnapshotFeedLabel(QLabel):
    """
    A label that displays the feed in the main window (live),
    but when clicked, opens a new SnapshotWindow with the last known frame
    (a still image).
    """
    def __init__(self, feed_url, refresh_interval=1.0, use_tor=False, parent=None):
        super().__init__(parent)
        self.feed_url = feed_url
        self.refresh_interval = refresh_interval
        self.use_tor = use_tor

        self._pixmap = None  # store last known snapshot
        self.setStyleSheet("""
            QLabel {
                color: #FFFFFF;
                font-weight: bold;
                background-color: transparent;
            }
            QLabel:hover {
                background-color: rgba(255, 255, 255, 0.07);
            }
        """)
        self.setCursor(QCursor(Qt.PointingHandCursor))

    def set_snapshot(self, qimage):
        """Called by the worker to update the displayed snapshot."""
        pixmap = QPixmap.fromImage(qimage)
        self._pixmap = pixmap
        scaled = pixmap.scaled(self.width(), self.height(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.setPixmap(scaled)

    def resizeEvent(self, event):
        """Rescale the snapshot to fit the new size if we have one."""
        if self._pixmap:
            scaled = self._pixmap.scaled(self.width(), self.height(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.setPixmap(scaled)
        super().resizeEvent(event)

    def mousePressEvent(self, event):
        """Open a new SnapshotWindow with the last known pixmap (if any)."""
        if event.button() == Qt.LeftButton and self._pixmap:
            snapshot_win = SnapshotWindow(self._pixmap)
            snapshot_win.show()
            # Store a reference so it's not GC'd
            if hasattr(self.parent(), "snapshot_windows"):
                self.parent().snapshot_windows.append(snapshot_win)
        super().mousePressEvent(event)

# #############################################################################
# Main CCTV Window
# #############################################################################
class CCTVWindow(QMainWindow):
    def __init__(self, urls, refresh_interval=1.0, max_cams=10, use_tor=False):
        super().__init__()
        self.urls = urls[:max_cams]
        self.refresh_interval = refresh_interval
        self.use_tor = use_tor
        self.setWindowTitle("PyQt CCTV Viewer - Material Dark Theme")

        # Keep references to worker threads
        self.workers = []
        # Keep references to child snapshot windows
        self.snapshot_windows = []

        main_widget = QWidget()
        main_layout = QVBoxLayout(main_widget)
        main_layout.setSpacing(0)  # minimize vertical spacing
        self.setCentralWidget(main_widget)

        # Header
        header_container = QWidget()
        header_layout = QVBoxLayout(header_container)
        header_layout.setSpacing(0)
        header_layout.setContentsMargins(0, 0, 0, 0)

        # Big label: "CCTV Feeds"
        header_label = QLabel("CCTV Feeds", header_container)
        header_label.setObjectName("headerLabel")
        header_label.setAlignment(Qt.AlignCenter)
        header_layout.addWidget(header_label)

        # Smaller label: "Made by [#AfterDark]"
        afterdark_label = QLabel("Made by [#AfterDark]", header_container)
        afterdark_label.setObjectName("afterDarkLabel")
        afterdark_label.setAlignment(Qt.AlignCenter)
        header_layout.addWidget(afterdark_label)

        main_layout.addWidget(header_container, alignment=Qt.AlignTop)

        # Scroll area for feeds
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        main_layout.addWidget(self.scroll_area, stretch=1)

        feeds_container = QWidget()
        self.feeds_layout = QGridLayout(feeds_container)
        feeds_container.setLayout(self.feeds_layout)
        self.scroll_area.setWidget(feeds_container)

        self.build_feed_cards()
        self.apply_style()

        # Window size
        screen = QApplication.primaryScreen().availableGeometry()
        w = int(screen.width() * 0.7)
        h = int(screen.height() * 0.7)
        self.setGeometry(50, 50, w, h)

    def apply_style(self):
        self.setStyleSheet(f"""
            QMainWindow {{
                background-color: {PRIMARY_BG};
            }}
            QWidget {{
                background-color: {PRIMARY_BG};
                color: {TEXT_COLOR};
                font-family: Roboto, Arial, sans-serif;
                font-size: 10pt;
            }}
            QLabel#headerLabel {{
                color: {ACCENT_COLOR};
                font-size: 18pt;
                font-weight: bold;
                margin: 0;
            }}
            QLabel#afterDarkLabel {{
                color: {SECONDARY_TEXT};
                font-size: 10pt;
                margin: 0;
            }}
            QScrollArea {{
                border: none;
            }}
        """)

    def build_feed_cards(self):
        """
        Create a card with a subtle drop shadow for each feed.
        Each card displays:
          - A SnapshotFeedLabel that shows the feed live in the main window
            and opens a SnapshotWindow (still image) on click
          - The resolved IP address
        """
        for i, url in enumerate(self.urls):
            row, col = divmod(i, 4)

            parsed = urlparse(url)
            host = parsed.hostname or "Unknown"
            try:
                resolved_ip = socket.gethostbyname(host)
            except Exception:
                resolved_ip = "Unknown"

            feed_frame = QFrame()
            feed_frame.setStyleSheet(f"""
                QFrame {{
                    background-color: {CARD_BG};
                    border-radius: 8px;
                }}
            """)
            shadow = QGraphicsDropShadowEffect()
            shadow.setBlurRadius(16)
            shadow.setColor(QColor(0, 0, 0, 160))
            shadow.setOffset(0, 4)
            feed_frame.setGraphicsEffect(shadow)

            layout = QVBoxLayout(feed_frame)
            layout.setContentsMargins(10, 10, 10, 10)

            # Label that shows the live feed snapshot & opens SnapshotWindow
            feed_label = SnapshotFeedLabel(url, refresh_interval=self.refresh_interval, use_tor=self.use_tor)
            feed_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
            feed_label.setMinimumSize(320, 240)
            feed_label.setAlignment(Qt.AlignCenter)
            # We'll store references to snapshot windows in feed_label's parent if needed
            feed_frame.snapshot_windows = self.snapshot_windows

            layout.addWidget(feed_label)

            # IP label
            ip_label = QLabel(f"IP: {resolved_ip}")
            ip_label.setAlignment(Qt.AlignCenter)
            ip_label.setStyleSheet(f"QLabel {{ color: {SECONDARY_TEXT}; font-size: 9pt; }}")
            layout.addWidget(ip_label)

            self.feeds_layout.addWidget(feed_frame, row, col, Qt.AlignCenter)

            # Worker for the live feed in main window
            worker = CameraFeedWorker(url, refresh_interval=self.refresh_interval, use_tor=self.use_tor)
            worker.image_updated.connect(lambda img, lbl=feed_label: lbl.set_snapshot(img))
            worker.error_signal.connect(self.on_feed_error)
            worker.start()
            self.workers.append(worker)

    def on_feed_error(self, msg):
        print("[Feed Error]", msg)

    def closeEvent(self, event):
        """
        1) Close any snapshot windows first
        2) Stop/wait main feed workers
        3) Then close
        """
        # Close child snapshot windows
        for sw in self.snapshot_windows:
            if sw.isVisible():
                sw.close()
        self.snapshot_windows.clear()

        # Now stop the main feed workers
        for w in self.workers:
            w.stop()
        time.sleep(0.3)

        super().closeEvent(event)

# #############################################################################
# UTILS
# #############################################################################
def extract_urls_from_file(file_path):
    urls = []
    try:
        with open(file_path, "r") as file:
            for line in file:
                if "Vulnerable Hikvision Camera" in line:
                    parts = line.split(": ", 1)
                    if len(parts) > 1:
                        urls.append(parts[1].strip())
    except Exception as e:
        print(f"[ERROR] Reading file: {e}")
    return urls

# #############################################################################
# TrafficMonitorWindow
# #############################################################################
class TrafficMonitorWindow(QMainWindow):
    def __init__(self, use_tor=False):
        super().__init__()
        self.use_tor = use_tor
        self.setWindowTitle("Network Traffic Monitor (Material Dark)")

        main_widget = QWidget()
        main_layout = QVBoxLayout(main_widget)
        self.setCentralWidget(main_widget)

        self.ip_label = QLabel("Fetching IP...", self)
        self.ip_label.setObjectName("ipLabel")
        main_layout.addWidget(self.ip_label, alignment=Qt.AlignHCenter)

        self.canvas = TrafficCanvas(parent=self, title="Tor Traffic" if self.use_tor else "Network Traffic")
        main_layout.addWidget(self.canvas)

        self.apply_style()

        # Timer for IP updates
        self.ip_timer = QTimer()
        self.ip_timer.timeout.connect(self.update_ip)
        self.ip_timer.start(5000)

        # Position + size
        screen = QApplication.primaryScreen().availableGeometry()
        width = int(screen.width() * 0.25)
        height = int(screen.height() * 0.3)
        x = int(screen.width() * 0.7) + 70
        y = 50
        self.setGeometry(x, y, width, height)

    def apply_style(self):
        self.setStyleSheet(f"""
            QMainWindow {{
                background-color: {PRIMARY_BG};
            }}
            QWidget {{
                background-color: {PRIMARY_BG};
                color: {TEXT_COLOR};
                font-family: Roboto, Arial, sans-serif;
            }}
            QLabel#ipLabel {{
                font-size: 14px;
                font-weight: bold;
                color: {ACCENT_COLOR};
                padding: 10px;
            }}
        """)

    def update_ip(self):
        try:
            session = get_tor_session() if self.use_tor else requests.Session()
            resp = session.get("http://httpbin.org/ip", timeout=5)
            if resp.status_code == 200:
                ip = resp.json().get("origin", "Unknown")
                if self.use_tor:
                    self.ip_label.setText(f"Tor Exit Node: {ip}")
                else:
                    self.ip_label.setText(f"Current IP: {ip}")
            else:
                self.ip_label.setText("Error fetching IP")
        except Exception as e:
            self.ip_label.setText("Error fetching IP")
            print("[ERROR]", e)

# #############################################################################
# MAIN
# #############################################################################
def main():
    parser = argparse.ArgumentParser(description="PyQt CCTV Viewer with Snapshot Windows")
    parser.add_argument("--file", "-f", required=True, help="Path to the file containing camera URLs")
    parser.add_argument("--refresh", "-r", type=float, default=1.0, help="Refresh interval in seconds")
    parser.add_argument("--max", "-m", type=int, default=10, help="Max number of camera feeds to display")
    parser.add_argument("--tor", "-t", action="store_true", help="Use the Tor network for camera feeds")
    parser.add_argument("--tor-check", action="store_true", help="Check if Tor is running, then exit")
    args = parser.parse_args()

    # 1) Print the scanner-like ASCII banner at startup
    print_banner()

    # 2) If user only wants to check Tor (without using it in the script)
    if args.tor_check and not args.tor:
        check_tor_running()
        sys.exit(0)

    app = QApplication(sys.argv)

    urls = extract_urls_from_file(args.file)
    if not urls:
        print("[ERROR] No valid camera URLs found. Exiting.")
        sys.exit(1)

    # Create and show the main CCTV window
    cctv_window = CCTVWindow(urls, refresh_interval=args.refresh, max_cams=args.max, use_tor=args.tor)
    cctv_window.show()

    # If Tor is used, optionally show Tor traffic monitor
    if args.tor:
        if not check_tor_running():
            print("[WARNING] Tor might not be running. The feeds may fail.")
        if args.tor_check:
            monitor = TrafficMonitorWindow(use_tor=True)
            monitor.show()
    else:
        monitor = TrafficMonitorWindow(use_tor=False)
        monitor.show()

    sys.exit(app.exec())

if __name__ == "__main__":
    main()
